# -*- coding: utf-8 -*-
"""GeneticAlgo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1px07Di9cA8N1K4N_RvuAqWA_i63uQmsV
"""

import numpy as np
import time
import random

goalState = np.array([1, 2, 3, 4, 5, 6, 7, 8, 0]).reshape(3, 3)
input_arr = np.array([1,3,2,4,6,5,8,7,0]).reshape(3, 3)

def h1(in_array):  #heuristic1, used to check on the basis of number of misplaced tiles
    #print(in_array)
    misplaced =0
    for r in range(0,3):
      for c in range(0,3):
        if(in_array[r][c]!= goalState[r][c] and in_array[r][c]!=0 ):
          misplaced +=1
    return misplaced

def h2(in_array): #heuristic2, used to check on the basis of manhattan distance
      goal_array =  np.copy(goalState)
      man_dis=0 #manhattan distance
      dic1={}#input map
      dic2={}#output map
      for r in range(0,3):
        for c in range(0,3):
          dic1[in_array[r][c]]=(r,c)
          dic2[goal_array[r][c]] = (r,c)

      for i in range(1,9):
        man_dis+=(abs(dic1[i][0]-dic2[i][0])) + (abs(dic1[i][1]-dic2[i][1]))
      return man_dis

def misplacedTilesInitial(input_arr):
    mispl=[]
    for r in range(0,3):
      for c in range(0,3):
        if(input_arr[r][c]!= goalState[r][c] and input_arr[r][c]!=0 ):
           mispl.append(input_arr[r][c])
    return mispl

# left move check
def checkLeft(ii,item):
     matrix = np.copy(ii)
     r,c = np.where(matrix == item)
     row = r[0]
     col = c[0]
     if col==0:
       return False,0
     matrix[row][col] = matrix[row][col-1]
     matrix[row][col-1] =item

     return True,matrix
     
#right move check
def checkRight(ii,item):
     matrix = np.copy(ii)
     r,c = np.where(matrix == item)
     row = r[0]
     col = c[0]
     if col ==2:
       return False,0
     matrix[row][col] = matrix[row][col+1]
     matrix[row][col+1] =item

     return True,matrix
      
#Up move check
def checkUp(ii,item):
     matrix = np.copy(ii)
     r,c = np.where(matrix == item)
     row = r[0]
     col = c[0]

     if row ==0:
       return False,0
     matrix[row][col] = matrix[row-1][col]
     matrix[row-1][col] =item

     return True,matrix
#Down move check
def checkDown(ii,item):
     matrix = np.copy(ii)     
     r,c = np.where(matrix == item)
     row = r[0]
     col = c[0] 

     if row ==2:
       return False,0
     matrix[row][col] = matrix[row+1][col]
     matrix[row+1][col] =item
     return True,matrix 

pQueue=[]
visitedStates=set([])
def createPopulation(input_arr,algo):
    if algo == "h1":
       pQueue.append((list(input_arr.flatten()),h1(input_arr)))
    else:
       pQueue.append((list(input_arr.flatten()),h2(input_arr))) 

    misplaced_tiles = misplacedTilesInitial(input_arr)
    for i in misplaced_tiles:
        l,lmat = checkLeft(input_arr,i)
        if l and tuple(lmat.flatten()) not in visitedStates:
          if algo == "h1":
             pQueue.append((list(lmat.flatten()),h1(lmat)))
          else:
             pQueue.append((list(lmat.flatten()),h2(lmat)))
          visitedStates.add(tuple(lmat.flatten()))
        d,dmat = checkDown(input_arr,i)
        if d and tuple(dmat.flatten()) not in visitedStates:
          if algo == "h1":
             pQueue.append((list(dmat.flatten()),h1(dmat)))
          else:
             pQueue.append((list(dmat.flatten()),h2(dmat)))
          visitedStates.add(tuple(dmat.flatten()))
        r,rmat = checkRight(input_arr,i)
        if r and tuple(rmat.flatten()) not in visitedStates:
          if algo == "h1":
             pQueue.append((list(rmat.flatten()),h1(rmat)))
          else:
             pQueue.append((list(rmat.flatten()),h2(rmat)))
          visitedStates.add(tuple(rmat.flatten()))
        u,umat = checkUp(input_arr,i)
        if u and tuple(umat.flatten()) not in visitedStates:
          if algo == "h1":
             pQueue.append((list(umat.flatten()),h1(umat)))
          else:
             pQueue.append((list(umat.flatten()),h2(umat)))
          visitedStates.add(tuple(umat.flatten()))
    #pQueue = sorted(pQueue, key=lambda x: x[1])
    #print(visitedStates)
    return pQueue


notRandom =[]
def getParents(population,rk): #selection process
   #implementing Roulette Wheel
    kParents =[]
    fitList = [p[1] for p in population]
    minF = min(fitList)
    maxF = max(fitList)
    sumF = sum(fitList) 
    for i in range(int(rk/2)):

        parents=[]
        for i in range(2):
            r = random.choice([i for i in range(0,sumF) if i not in notRandom])#random.randint(0,sumF)
            #print(r)
            s=fitList[0]
            fitI=0
            while(s<r):
              fitI+=1
              s+=fitList[fitI] 
            parents.append(fitI)
            notRandom.append(r)
        kParents.append(parents)

    print("Parents selected for crossover and mutation using Roulette wheel:- ",kParents)
    return kParents, maxF

def crossover(parent1,parent2):
    #parent1 = parent1.flatten()
    #parent2 = parent2.flatten()
    #print(parent1,parent2) 
    cp=3 #crossover point is 4
    crossOver = []
    crossOver2 = []
    temp = []
    temp = parent1
    crossOver = parent1[0:4] #copying parent first four elements
    crossOver2 = parent2[0:4]
    for e in parent2:
        if e not in crossOver:
           crossOver = np.append(crossOver,e)
    for e in temp:
        if e not in crossOver2:
           crossOver2 = np.append(crossOver2,e)
    #print(crossOver,crossOver2)
    return crossOver,crossOver2

def mutation(offsprings): #with small probability swapping two numbers
    for o in range(len(offsprings)):
        rr = round( random.uniform(0, 1), 4)
        #print(rr)
        if rr < 0.2:
          #offspring = offsprings[o]
          print("Mutation for offspring:- ",offsprings[o])
          i = random.randint(0,8)
          j = random.randint(0,8)
          t = offsprings[o][i]
          offsprings[o][i] = offsprings[o][j]
          offsprings[o][j] = t

    return offsprings

def checkGoal(population):
    states = []
    g = goalState.flatten()
    for p in range(len(population)):
      states.append(population[p][0])
      if (g == population[p][0]).all():
        #print(population[p][0])
        return True
      else:
        return False
    
   # states = [p[0] for p in population]
    #print(states)
    
    
def GenAlgo(algo):
    population = createPopulation(input_arr,algo)
    population = sorted(population, key=lambda x: x[1])
    
    count=0
    while population:
          count+=1
          print("Step number- ",count)
          print("Population- ",population)
          t = checkGoal(population)
          if t:
            print("success at step- ",count)
            break
          
          pSize = len(population)
          rk = random.randrange(2,pSize,2)
          notRandom.clear()
          parents,maxF= getParents(population,rk)
          #print(pSize,rk,parents,len(parents))
          #print(parents[0],parents[1])
          
          offsprings=[]
          for i in range(len(parents)):
              rr = round( random.uniform(0, 1), 4)
              if rr > 0.6:
                  offspring1, offspring2 = crossover(population[parents[i][0]][0],population[parents[i][1]][0])
                  offsprings.append(list(offspring1))
                  offsprings.append(list(offspring2))
          #print(offsprings)
          
          print("Offsprings generated:- ",offsprings)
          offsprings = mutation(offsprings)
          #print(offsprings)
          #print(minF)
          popIndex = 1
          for i in range(len(offsprings)):
              if tuple(offsprings[i]) not in visitedStates:
                  hval =0
                  if algo == "h1":
                      hval = h1(np.reshape(offsprings[i],(3, 3)))
                      #print(hval)
                  else:
                      hval = h2(np.reshape(offsprings[i],(3, 3)))
                      #print(hval)
                  if hval<maxF:
                    population[pSize-popIndex] = (list(offsprings[i]),hval)
                    #population.append((offsprings[i],hval))
                    visitedStates.add(tuple(offsprings[i]))
                    popIndex+=1
          #print(popIndex,population)
          population = sorted(population, key=lambda x: x[1])
          print("-----------------------------------------------------------------------------------------")
          """
          print(offspring)
          if tuple(offspring) not in visitedStates:
            hval = h1(np.reshape(offspring,(3, 3)))
            if hval<=minF:
              population.append((offspring,hval))
              visitedStates.add(tuple(offspring))
              population = sorted(population, key=lambda x: x[1])
          """

          ##### Add convergence criteria  

print("Genetic Algorithm fitness function misplaced tiles")
print("Input State",input_arr)
print("Goal State",goalState)
start = time.time()
GenAlgo("h1")
end = time.time()
print("Time taken for h1-", "{:.6f}s".format(end-start))
print("=====================================================================================================")
pQueue.clear()
visitedStates.clear()
count=0
print("Genetic Algorithm fitness function misplaced tiles")
print("Input State",input_arr)
print("Goal State",goalState)
start = time.time()
GenAlgo("h2")
end = time.time()
print("Time taken for h2-", "{:.6f}s".format(end-start))